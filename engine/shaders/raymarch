#version 410 core
////////////////////////////////////////////////////////////////////////////////////////
// Constants
#define MAX_STEPS 128
#define RAY_MIN_STEP 0.01
#define RAY_MAX_STEP 100
#define EPSILON 0.01f

////////////////////////////////////////////////////////////////////////////////////////
// Types
struct Ray
{
    vec3 ro;
    vec3 rd;
};

////////////////////////////////////////////////////////////////////////////////////////
// Math Util
// Rotation matrix around the X axis.
mat3 rotateX(float theta) {
    float c = cos(theta);
    float s = sin(theta);
    return mat3(
        vec3(1, 0, 0),
        vec3(0, c, -s),
        vec3(0, s, c)
    );
}

// Rotation matrix around the Y axis.
mat3 rotateY(float theta) {
    float c = cos(theta);
    float s = sin(theta);
    return mat3(
        vec3(c, 0, s),
        vec3(0, 1, 0),
        vec3(-s, 0, c)
    );
}

// Rotation matrix around the Z axis.
mat3 rotateZ(float theta) {
    float c = cos(theta);
    float s = sin(theta);
    return mat3(
        vec3(c, -s, 0),
        vec3(s, c, 0),
        vec3(0, 0, 1)
    );
}

// Identity matrix.
mat3 identity() {
    return mat3(
        vec3(1, 0, 0),
        vec3(0, 1, 0),
        vec3(0, 0, 1)
    );
}

////////////////////////////////////////////////////////////////////////////////////////
// in/out variables

uniform vec4 rocks[100];
uniform ivec2 resolution;

uniform float cameraYaw;
uniform float cameraPitch;
uniform vec3 cameraPos;
uniform vec3 cameraForward;
uniform mat4 viewMatrix;

out vec4 FragColor;
////////////////////////////////////////////////////////////////////////////////////////
// SDF Utils

float sphereSDF(vec3 p, vec4 circle)
{
    return length(p-circle.xyz) - circle.w;
}

float sdBox( vec3 p, vec3 b )
{
  vec3 q = abs(p) - b;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

////////////////////////////////////////////////////////////////////////////////////////
// SDF Scene description
float sceneSDF(vec3 p)
{
    float hit = RAY_MAX_STEP;
    for(int k = 0; k < 10; k++)
    {
        hit = min(hit, sphereSDF(p, rocks[k]));
    }
    //hit = min(hit, sdBox(p, vec3(0.2)));
    return hit;
}

vec3 estimateNormal(vec3 p) {
    return normalize(vec3(
        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),
        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),
        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))
    ));
}

////////////////////////////////////////////////////////////////////////////////////////
// Ray Marching
float raymarch(Ray ray){
    float depth = 0;
    for(int i = 0; i < MAX_STEPS; i++)
    {
        vec3 p = ray.ro + ray.rd * depth;
        float hit = sceneSDF(p);
        depth += hit;
        if(depth > RAY_MAX_STEP || depth < RAY_MIN_STEP) break;
    }
    return depth;
}
////////////////////////////////////////////////////////////////////////////////////////
// MAIN
void main()
{
    vec2 uv = (gl_FragCoord.xy - 0.5 * resolution.xy) / resolution.y;
    //uv.x *= resolution.x / resolution.y;  // Adjust for aspect ratio
    Ray ray;
    ray.ro = vec4(vec4(cameraPos, 1.0f)).xyz; // camera eye aka ray origin
    
    // dir
    //ray.ro = (vec4(cameraPos, 1.0)).xyz;
    ray.rd = normalize(vec3(uv, 1));
    ray.rd *= rotateX(cameraPitch);
    ray.rd *= rotateY(-cameraYaw);

    float d  = raymarch(ray);
    if(d < RAY_MAX_STEP)
    {
        vec3 lightDir = vec3(-5, 5, -2);

        vec3 hitPoint = ray.ro + ray.rd * d;

        vec3 normal = normalize(estimateNormal(hitPoint));

        float diffuse = clamp(dot(normal, lightDir), 0.0f, 1.0f) * 0.8f;
        FragColor = vec4(vec3(normal),1.0);  
    }
    else
    {
        // Render the skybox
        FragColor = vec4(0.0f, 0.0f, 0.0f, 1.0);  
    }
}

