#version 410 core

////////////////////////////////////////////////////////////////////////////////////////
// Constants
#define MAX_STEPS 128
#define RAY_MIN_STEP 0.01
#define RAY_MAX_STEP 100.0
#define EPSILON 0.01

////////////////////////////////////////////////////////////////////////////////////////
// Types
struct Ray {
    vec3 ro; // Ray origin
    vec3 rd; // Ray direction
};

struct SDF_Node {
    int type;     // 0 = Sphere, 1 = Box, 2 = Capsule, etc.
    vec4 params;  // Sphere: xyz=center, w=radius; Box: xyz=size, w=unused
    int op;       // -1 = None, 0 = Union, 1 = Intersection, 2 = Subtraction
    int left;     // Index of the left child node
    int right;    // Index of the right child node
};

////////////////////////////////////////////////////////////////////////////////////////
// Uniforms
uniform ivec2 resolution;         // Screen resolution
uniform SDF_Node sdf_nodes[100];  // Scene description (node-based)
uniform int sdf_node_count;       // Number of SDF nodes
uniform vec3 light_pos;           // Position of the light source

in vec4 nearp;
in vec4 farp;

out vec4 FragColor;

////////////////////////////////////////////////////////////////////////////////////////
// SDF Primitive Functions
float sphereSDF(vec3 p, vec4 params) {
    return length(p - params.xyz) - params.w;
}

float boxSDF(vec3 p, vec3 size) {
    vec3 q = abs(p) - size;
    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

////////////////////////////////////////////////////////////////////////////////////////
// SDF Combination Operations
float unionOp(float d1, float d2) {
    return min(d1, d2);
}

float intersectOp(float d1, float d2) {
    return max(d1, d2);
}

float subtractOp(float d1, float d2) {
    return max(d1, -d2);
}

////////////////////////////////////////////////////////////////////////////////////////
// Scene SDF Evaluation
float sceneSDF(vec3 p, int node_index) {
    if (node_index < 0) return RAY_MAX_STEP;

    SDF_Node node = sdf_nodes[node_index];
    float d;

    // Evaluate the SDF for the current node
    if (node.type == 0) { // Sphere
        d = sphereSDF(p, node.params);
    } else if (node.type == 1) { // Box
        d = boxSDF(p, node.params.xyz);
    } else {
        d = RAY_MAX_STEP;
    }

    // Combine with child nodes using the operation
    if (node.op == 0) { // Union
        d = unionOp(d, sceneSDF(p, node.left));
        d = unionOp(d, sceneSDF(p, node.right));
    } else if (node.op == 1) { // Intersection
        d = intersectOp(d, sceneSDF(p, node.left));
        d = intersectOp(d, sceneSDF(p, node.right));
    } else if (node.op == 2) { // Subtraction
        d = subtractOp(d, sceneSDF(p, node.left));
        d = subtractOp(d, sceneSDF(p, node.right));
    }

    return d;
}

////////////////////////////////////////////////////////////////////////////////////////
// Normal Estimation
vec3 estimateNormal(vec3 p) {
    return normalize(vec3(
        sceneSDF(vec3(p.x + EPSILON, p.y, p.z), 0) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z), 0),
        sceneSDF(vec3(p.x, p.y + EPSILON, p.z), 0) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z), 0),
        sceneSDF(vec3(p.x, p.y, p.z + EPSILON), 0) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON), 0)
    ));
}

////////////////////////////////////////////////////////////////////////////////////////
// Ray Marching
float raymarch(Ray ray) {
    float depth = 0.0;

    for (int i = 0; i < MAX_STEPS; ++i) {
        vec3 p = ray.ro + ray.rd * depth;
        float dist = sceneSDF(p, 0); // Start from the root node

        if (dist < RAY_MIN_STEP) {
            return depth; // Hit the surface
        }

        depth += dist;

        if (depth > RAY_MAX_STEP) {
            break; // Exit if the ray exceeds max depth
        }
    }

    return RAY_MAX_STEP; // Did not hit anything
}

////////////////////////////////////////////////////////////////////////////////////////
// Main
void main() {
    vec2 uv = (gl_FragCoord.xy - 0.5 * resolution.xy) / resolution.y;

    Ray ray;
    ray.ro = nearp.xyz / nearp.w; // Ray origin in world space
    ray.rd = normalize((farp.xyz / farp.w) - ray.ro); // Ray direction

    // Perform ray marching
    float depth = raymarch(ray);

    if (depth < RAY_MAX_STEP) {
        // Hit surface, calculate shading
        vec3 p = ray.ro + ray.rd * depth;
        vec3 n = estimateNormal(p);
        vec3 l = normalize(light_pos - p);
        vec3 v = normalize(ray.ro - p);
        vec3 r = reflect(-l, n);

        float diff = max(dot(n, l), 0.0); // Diffuse shading
        float spec = pow(max(dot(r, v), 0.0), 32.0); // Specular shading

        vec3 color = vec3(0.3, 0.5, 0.8) * diff + vec3(1.0) * spec;

        FragColor = vec4(color, 1.0);
        gl_FragDepth = depth / RAY_MAX_STEP;
    } else {
        // Miss, background color
        FragColor = vec4(0.0, 0.0, 0.0, 1.0);
        gl_FragDepth = 1.0;
    }
}