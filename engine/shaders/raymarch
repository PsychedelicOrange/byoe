#version 410 core

#define MAX_STEPS 128
#define RAY_MIN_STEP 0.01
#define RAY_MAX_STEP 100
#define EPSILON 0.01f

struct Ray
{
	vec3 ro;
	vec3 rd;
};

out vec4 FragColor;

uniform vec4 rocks[100];
uniform ivec2 resolution;

uniform vec3 cameraForward;
// uniform vec3 cameraRight;
// uniform vec3 cameraUp;

uniform vec3 cameraPos;

float sphereSDF(vec3 p, vec4 circle)
{
	return length(p-circle.xyz) - circle.w;
}

float sdBox( vec3 p, vec3 b )
{
  vec3 q = abs(p) - b;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

float sceneSDF(vec3 p)
{
	float hit = RAY_MAX_STEP;
	for(int k = 0; k < 10; k++)
	{
		hit = min(hit, sphereSDF(p, rocks[k]));
	}
	//hit = min(hit, sdBox(p, vec3(0.2)));
	return hit;
}

vec3 estimateNormal(vec3 p) {
    return normalize(vec3(
        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),
        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),
        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))
    ));
}

float raymarch(Ray ray){
	float depth = 0;
	for(int i = 0; i < MAX_STEPS; i++)
	{
		vec3 p = ray.ro + ray.rd * depth;
		float hit = sceneSDF(p);
		depth += hit;
		if(depth > RAY_MAX_STEP || depth < RAY_MIN_STEP) break;
	}
	return depth;
}

void main()
{
	vec2 uv = (gl_FragCoord.xy - 0.5 * resolution.xy) / resolution.y;
	uv.x *= resolution.x / resolution.y;  // Adjust for aspect ratio
	Ray ray;
	ray.ro = cameraPos; // camera eye aka ray origin
	//ray.rd = normalize(((vec4(uv.x, uv.y, 1.0f, 1.0f) * viewProjection)).xyz); // ray direction
	ray.rd = normalize(vec3(uv.x, uv.y, 1.0f) + cameraForward); // Combine forward, right, and up to get the correct direction

	float d  = raymarch(ray);
	if(d < RAY_MAX_STEP)
	{
		vec3 lightDir = vec3(-5, 5, -2);

		vec3 hitPoint = ray.ro + ray.rd * d;

		vec3 normal = normalize(estimateNormal(hitPoint));

		float diffuse = clamp(dot(normal, lightDir), 0.0f, 1.0f) * 0.8f;
    	FragColor = vec4(vec3(diffuse),1.0);  
	}
	else
	{
		// Render the skybox
		FragColor = vec4(0.0f, 0.0f, 0.0f, 1.0);  
	}
}

